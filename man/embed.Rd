% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/embed.R
\name{embed}
\alias{embed}
\title{Probability-based Embedding}
\usage{
embed(df, indexes = NULL, method = "tsne", alpha = 1, lambda = 0.5,
  kappa = 0.5, scale_type = "", perplexity = 32, perp_scale = "single",
  perp_scale_iter = NULL, perp_kernel_fun = "exp", prec_scale = "",
  init = "p", init_config = NULL, opt = "NAG-BOLD", max_iter = 1000,
  report_every = 50, tol = 1e-04, plot_type = "p", label_name = NULL,
  label_chars = NULL, label_size = 1, palette = "Set1", legend = TRUE,
  legend_rows = NULL, quality_measures = NULL, ret = c())
}
\arguments{
\item{df}{Data frame to embed.}

\item{indexes}{Indexes of the columns of the numerical variables to use in
the embedding. The default of \code{NULL} will use all the numeric
variables.}

\item{method}{Embedding method. See 'Details'.}

\item{alpha}{Heavy tailedness parameter. Used only if the method is
\code{"hssne"}.}

\item{lambda}{NeRV parameter. Used only if the method is \code{"nerv"}.}

\item{kappa}{JSE parameter. Used only if the method is \code{"jse"}.}

\item{scale_type}{Type of scaling to carry out on the input data. See
'Details'.}

\item{perplexity}{Target perplexity or vector of trial perplexities (if
\code{perp_scale} is set). Applies to probability-based embedding methods
only (i.e. anything that isn't PCA, MDS or Sammon mapping).}

\item{perp_scale}{Type of perplexity scaling to apply. See 'Details'. Ignored
by non-probability based methods.}

\item{perp_scale_iter}{Number of iterations to scale perplexity values over.
Must be smaller than the \code{max_iter} parameter. Default is to use
\code{max_iter / 5}. Ignored by non-probability based methods or if
\code{perp_scale} is not set.}

\item{perp_kernel_fun}{The input data weight function. Either \code{"exp"}
to use exponential function (the default) or \code{"step"} to use a step
function. The latter emulates a k-nearest neighbor graph, but does not
provide any of the efficiency advantages of a sparse matrix.}

\item{prec_scale}{Whether to scale the output kernel precision based on
perplexity results. See 'Details'. Ignored by non-probability based methods.
Can't be used if \code{perp_kernel_fun} is set to \code{"step"}.}

\item{init}{Type of initialization of the output coordinates. See 'Details'.}

\item{init_config}{Coordinates to use for initial configuration. Used only
if \code{init} is \code{"m"}.}

\item{opt}{Type of optimizer. See 'Details'.}

\item{max_iter}{Maximum number of iterations to carry out optimization of
the embedding. Ignored if the \code{method} is \code{"pca"}.}

\item{report_every}{Frequency (in terms of iteration number) with which to
update plot and report the cost function.}

\item{tol}{Tolerance for comparing cost change (calculated according to the
interval determined by \code{report_every}). If the change falls below this
value, the optimization stops early.}

\item{plot_type}{String code indicating the type of plot of the embedding
to display: \code{"p"} to use the usual \code{\link[graphics]{plot}}
function; \code{"g"} to use the \code{ggplot2} package, with the
\code{RColorBrewer} palettes. You are responsible for installing and
loading these packages yourself.}

\item{label_name}{Name of factor-typed column in \code{df} to be used to
color the points in the embedding plot (for \code{plot_type}
\code{"g"}) or to color the text associated with each plotted observation
{\code{plot_type "p"}}. If not specified, then the first factor column
will be used. If no suitable column can be found, then no plotting
is carried out.}

\item{label_chars}{Number of characters to use for the labels in the
embedding plot. Applies only when \code{plot_type} is set to \code{"p"}.}

\item{label_size}{Size of the points in the embedding plot.}

\item{palette}{Color Brewer palette name to use for coloring points in embedding
plot. Applies to \code{plot_type} type \code{"g"} only.}

\item{legend}{if \code{TRUE}, display the legend in the embedding plot.
Applies when \code{plot_type} is \code{"g"} only.}

\item{legend_rows}{Number of rows to use for displaying the legend in
an embedding plot.}

\item{quality_measures}{Vector of names of quality measures to apply to the
finished embedding. See 'Details'. Values of the quality measures will
be printed to screen after embedding and retained in the list that is
returned from this function.}

\item{ret}{Vector of names of extra data to return from the embedding. See
'Details',}
}
\value{
List with the following elements:
\itemize{
\item \code{coords} Embedded coordinates.
\item \code{cost} Cost function value for the embedded coordinates. The
 type of the cost depends on the method, but the lower the better.
\item \code{norm_cost} \code{cost}, normalized so that a perfect embedding
 gives a value of 0 and one where all the distances were equal would have
 a value of 1.
\item \code{method} String giving the method used for the embedding.
}
Additional elements will be in the list if \code{ret} or
\code{quality_measures} are non-empty.
}
\description{
Carries out an embedding of a high-dimensional dataset into a two dimensional
scatter plot, based on distance-based methods (e.g. Sammon maps) and
probability-based methods (e.g. t-distributed Stochastic Neighbor Embedding).
}
\details{
The embedding methods available are:
\itemize{
 \item \code{"pca"} The first two principal components.
 \item \code{"mmds"} Metric multidimensional scaling.
 \item \code{"sammon"} Sammon map.
 \item \code{"tsne"} t-Distributed Stochastic Neighbor Embedding of van der
  Maaten and Hinton (2008).
 \item \code{"asne"} Asymmetric Stochastic Neighbor Embedding of Hinton and
  Roweis (2002).
 \item \code{"ssne"} Symetric Stochastic Neighbor Embedding of Cook et al
  (2007).
 \item \code{"wssne"} Weighted Symmetric Stochastic Neighbor Embedding of
  Yang et al (2014). Note that despite its name this version is a
  modification of t-SNE, not SSNE.
 \item \code{"hssne"} Heavy-tailed Symmetric Stochastic Neighbor Embedding of
  Yang et al (2009).
 \item \code{"nerv"} Neighbor Retrieval Visualizer of Venna et al (2010).
 \item \code{"jse"} Jensen-Shannon Embedding of Lee at al (2013).
}

The following scaling options can be applied via the \code{scale_type}
parameter:
\itemize{
 \item \code{"m"} Range scale the entire data so that the maximum value is
  1 and the minimum 0.
 \item \code{"r"} Range scale each column that the maximum value in each
  column is 1 and the minimum 0.
 \item \code{"a"} Scale each column so that its mean is 0 and variance is
  1.
}
Default is to do no scaling. Zero variance columns will be removed even if no
preprocessing is carried out.

The \code{perplexity} parameter is used in combination with the
\code{perp_scale} parameter, which can take the following values:
\itemize{
 \item \code{"single"} \code{perplexity} should be a single value, which
   will be used over the entire course of the embedding.
 \item \code{"step"} \code{perplexity} should be a vector of
    perplexity values. Each perplexity will be used in turn over the course
    of the embedding, in sequential order. By starting with a large
    perplexity, and ending with the desired perplexity, it has been
    suggested by some researchers that local minima can be avoided.
\item \code{"multi"} The multiscaling method of Lee et al (2015).
    \code{perplexity} should be a vector of perplexity values. Each
    perplexity will be used in turn over the course of the embedding, in
    sequential order. Unlike with the \code{"step"} method, probability
    matrices from earlier perplexities are retained and combined by
    averaging.
}

For \code{perp_scale} values that aren't \code{"single"}, if a non-vector
argument is suppied to the \code{perplexity} argument, it will be ignored,
and a suitable vector of perplexity values will be used instead. For
\code{"multi"} these will range from the the number of observations in the
dataset divided by four down to 2, in descending powers of 2. For
\code{"step"}, 5 equally spaced values ranging from the number of
observations divided by 2 down to 32 (or the number of observations divided
by 4, if the dataset is smaller than 65 observations.)

The \code{prec_scale} parameter determines if the input weighting kernel
parameters should be used to modify the output kernel parameter after the
input probability calculation for a given perplexity value completes.
values are:
\itemize{
 \item \code{"n"} Do nothing. Most embedding methods follow this strategy,
   leaving the output similarity kernels to all have unit precision
   parameters.
 \item \code{"t"} Transfer the input similarity kernel parameters to the
   output similarity kernel. This method was suggesed by Venna et al (2010).
 \item \code{"s"} Scale the output kernel precisions based on the target
   \code{perplexity} and the intrinsic dimensionality of the input data. This
   method is part of the multiscaling technique proposed by Lee et al (2015).
}

The \code{prec_scale} parameter will be ignored if the \code{method} used
does not use an output similarity kernel with a free parameter, e.g.
\code{tsne} or \code{wtsne}. Also, because the input and output similarity
kernels must be of the same type, \code{prec_scale} is incompatible with
setting \code{perp_kernel_fun} to "step".

For initializing the output coordinates, the options for the
\code{init} parameter are:
\itemize{
 \item \code{"p"} Initialize using the first two scores of the PCA.
 Data will be centered, but not scaled unless the \code{scale_type} parameter
 is used.
 \item \code{"r"} Initialize each coordinate vlaue from a normal random
 distribution with a standard deviation of 1e-4, as suggested by van der
 Maaten and Hinton (2008).
 \item \code{"u"} Initialize each coordinate value from a uniform random
 distribution between 0 and 1 as suggested by Venna et al (2010).
 \item \code{"u"} Initialize the coordinates from a user-supplied matrix.
  Supply the coordinates as the \code{init_config} parameter.
}

For configuring the optimization method, the options for the \code{opt}
parameter are:
\itemize{
 \item \code{"L-BFGS"} The low-memory BFGS method.
 \item \code{"NAG-BOLD"} Nesterov Accelerated Gradient with bold driver step
   size selection.
 \item \code{"NAG-MT"} Nesterov Accelerated Gradient with More-Thuente step
   size selection.
 \item \code{"NAG-R"} Nesterov Accelerated Gradient with Rasmussen step size
  selection.
 \item \code{"CG-MT"} Conjugate Gradient with More-Thuente step size
 selection.
 \item \code{"CG-R"} Conjugate Gradient with Rasmussen step size selection.
}

There are some caveats to using these optimization routines:

\itemize{
 \item To use the conjugate gradient method or the Rasmussen or More-Thuente
  step size methods, you must install and load the \code{rcgmin} package from
  \url{https://github.com/jlmelville/rcgmin}.
 \item The external optimization routines (\code{L-BFGS} and \code{CG-}
  methods) run in batches of \code{report_every}. For example, if you want to
  report every 50 iterations, the optimization routine will be run for 50
  iterations, the cost is logged to screen, and then a new batch of 50
  iterations are run, losing any memory of the previous direction or other
  state, effectively "resetting" the search. Therefore, do not set
  \code{report_every} too low in this case, or the optimization will
  approach the behavior of steepest descent.
 \item Use of the external optimization routines is incompatible with
  \code{perp_scale} settings that need to update the input probabilities at
  certain iterations (e.g. multiscaling), because that iteration number might
  have been "lost" inside the optimization routine.
}

For the \code{quality_measures} argument, a vector with one or more of the
following options can be supplied:
\itemize{
 \item \code{"r"} Calculate the area under the ROC curve, averaged over
  each observation, using the output distance matrix to rank each
  observation. Observations are partitioned into the positive and negative
  class depending upon the value of the label determined by the
  \code{label_name} argument. Only calculated if the \code{label_name}
  parameter is supplied.
 \item \code{"p"} Calculate the area under the Precision-Recall curve.
  Only calculated if the \code{label_name} parameter is supplied.
 \item \code{"n"} Calculate the area under the RNX curve, using the
  method of Lee et al (2015).
}

For the \code{ret} argument, a vector with one or more of the
following options can be supplied:
\itemize{
 \item \code{"x"} The input coordinates after scaling and column filtering.
 \item \code{"dx"} The input distance matrix. Calculated if not present.
 \item \code{"dy"} The output distance matrix. Calculated if not present.
 \item \code{"p"} The input probability matrix.
 \item \code{"q"} The output probability matrix.
 \item \code{"prec"} The input similarity kernel precisions.
 \item \code{"dim"} The intrinsic dimensionality for each observation,
 calculated according to the method of Lee et al (2015). These are
 meaningless if not using the default exponential \code{perp_kernel_fun}.
 \item \code{"deg"} Degree centrality of the input probability. Calculated
 if not present.
}
}
\examples{
\dontrun{
  # PCA on iris dataset and plot result using Species label name
  res <- embed(iris, indexes = 1:4, label_name = "Species", method = "pca")
  # Same as above, but with sensible defaults (use all numeric columns, plot
  # with first factor column found)
  res <- embed(iris, method = "pca")
  # scale columns so each one has mean 0 and variance 1
  res <- embed(iris, method = "pca", scale_type = "a")
  # full species name on plot is cluttered, so just use the first two
  # letters and half size
  res <- embed(iris, method = "pca", scale_type = "a", label_chars = 2,
               label_size = 0.5)

  library(ggplot2)
  library(RColorBrewer)
  # Use ggplot2 and RColorBrewer palettes for the plot
  res <- embed(iris, method = "pca", scale_type = "a", plot_type = "g")
  # Use a different ColorBrewer palette, bigger points, and range scale each
  # column
  res <- embed(iris, method = "pca", scale_type = "r", plot_type = "g",
               palette = "Dark2", label_size = 2)

  # metric MDS starting from the PCA
  res <- embed(iris, method = "mmds", scale_type = "a", init = "p")
  # Sammon map starting from random distribution
  res <- embed(iris, method = "sammon", scale_type = "a", init = "r")

  # TSNE with a perplexity of 32, initialize from PCA
  res <- embed(iris, method = "tsne", scale_type = "a", init = "p",
               perplexity = 32)
  # default settings are to use TSNE with perplexity 32 and initialization
  # from PCA so the following is the equivalent of the above
  res <- embed(iris, scale_type = "a")

  # Use the L-BFGS optimization method
  res <- embed(iris, scale_type = "a", opt = "L-BFGS")

  # Load the rcgmin library
  install.packages("devtools")
  devtools::install_github("jlmelville/rcgmin")
  library("rcgmin")
  # Use More-Thuente line search with NAG optimizer instead of bold driver
  res <- embed(iris, scale_type = "a", opt = "NAG-MT")
  # Use Rasmussen line search
  res <- embed(iris, scale_type = "a", opt = "NAG-R")
  # Use Conjugate Gradient with More-Thuente line search
  res <- embed(iris, scale_type = "a", opt = "CG-R")

  # NeRV method, starting at a more global perplexity and slowly stepping
  # towards a value of 32 (might help avoid local optima)
  res <- embed(iris, scale_type = "a", method = "nerv", perp_scale = "step")

  # NeRV method has a lambda parameter - closer to 1 it gets, the more it
  # tries to avoid false positives (close points in the map that aren't close
  # in the input space):
  res <- embed(iris, scale_type = "a", method = "nerv", perp_scale = "step",
               lambda = 1)

  # Original NeRV paper transferred input exponential similarity kernel
  # precisions to the output kernel, and initialized from a uniform random
  # distribution
  res <- embed(iris, scale_type = "a", method = "nerv", perp_scale = "step",
               lambda = 1, prec_scale = "t", init = "u")

  # Like NeRV, the JSE method also has a controllable parameter that goes
  # between 0 and 1, called kappa. It gives similar results to NeRV at 0 and
  # 1 but unfortunately the opposite way round! The following gives similar
  # results to the NeRV embedding above:
  res <- embed(iris, scale_type = "a", method = "jse", perp_scale = "step",
               kappa = 0)

  # Rather than step perplexities, use multiscaling to combine and average
  # probabilities across multiple perplexities. Output kernel precisions
  # can be scaled based on the perplexity value (compare to NeRV example
  # which transferred the precision directly from the input kernel)
  res <- embed(iris, scale_type = "a", method = "jse", perp_scale = "multi",
               prec_scale = "s")

  # HSSNE has a controllable parameter, alpha, that lets you control how
  # much extra space to give points compared to the input distances.
  # Setting it to 1 is equivalent to TSNE, so 1.1 is a bit of an extra push:
  res <- embed(iris, scale_type = "a", method = "hssne", alpha = 1.1)

  # wTSNE treats the input probability like a graph where the probabilities
  # are weighted edges and adds extra repulsion to nodes with higher degrees
  res <- embed(iris, scale_type = "a", method = "wtsne")

  # can use a step-function input kernel to make input probability more like
  # a k-nearest neighbor graph (but note that we don't take advantage of the
  # sparsity for performance purposes, sadly)
  res <- embed(iris, scale_type = "a", method = "wtsne",
               perp_kernel_fun = "step")

  # Some quality measures are available to quantify embeddings
  # The area under the RNX curve measures whether neighbors in the input
  # are still neighors in the output space
  res <- embed(iris, scale_type = "a", method = "wtsne",
               quality_measures =  c("n"))

  # If your dataset labels divide the data into natural classes, can
  # calculate average area under the ROC and/or precision-recall curve too,
  # but you need to have installed the PRROC package.
  # All these techniques can be slow (scale with the square of the number of
  # observations).
  library(PRROC)
  res <- embed(iris, scale_type = "a", method = "wtsne",
               quality_measures =  c("n", "r", "p"))

  # export the distance matrices and do whatever quality measures we
  # want at our leisure
  res <- embed(iris, scale_type = "a", method = "wtsne", ret = c("dx", "dy"))

  # Calculate the Area Under the Precision Recall Curve for the embedding
  pr <- pr_auc_embed(res$dy, iris$Species)

  # Similarly, for the ROC curve:
  roc <- roc_auc_embed(res$dy, iris$Species)

  # calculate the 32-nearest neighbor preservation for each observation
  # 0 means no neighbors preserved, 1 means all of them
  pres32 <- nbr_pres(res$dx, res$dy, 32)

  # use map2color helper function with diverging or sequential color palettes
  # to map values onto the embedded points
  plot(res$coords, col = map2color(pres32), pch = 20, cex = 1.5)

  # export degree centrality, input weight function precision parameters,
  # and intrinsic dimensionality
  res <- embed(iris, scale_type = "a", method = "wtsne",
               ret = c("deg", "prec", "dim"))

  # Load the RColorBrewer Library
  library(RColorBrewer)
  # Visualize embedding colored by various values:
  # Degree centrality
  embed_quant_plot(res$coords, res$deg)
  # Intrinsic Dimensionality using the PRGn palette
  embed_quant_plot(res$coords, res$dim, name = "PRGn")
  # Input weight function precision parameter with the Spectral palette
  embed_quant_plot(res$coords, res$prec, name = "Spectral")
}
}
\references{
Cook, J., Sutskever, I., Mnih, A., & Hinton, G. E. (2007).
Visualizing similarity data with a mixture of maps.
In \emph{International Conference on Artificial Intelligence and Statistics} (pp. 67-74).

Hinton, G. E., & Roweis, S. T. (2002).
Stochastic neighbor embedding.
In \emph{Advances in neural information processing systems} (pp. 833-840).

Lee, J. A., Renard, E., Bernard, G., Dupont, P., & Verleysen, M. (2013).
Type 1 and 2 mixtures of Kullback-Leibler divergences as cost functions in
dimensionality reduction based on similarity preservation.
\emph{Neurocomputing}, \emph{112}, 92-108.

Lee, J. A., Peluffo-Ordo'nez, D. H., & Verleysen, M. (2015).
Multi-scale similarities in stochastic neighbour embedding: Reducing
dimensionality while preserving both local and global structure.
\emph{Neurocomputing}, \emph{169}, 246-261.

Van der Maaten, L., & Hinton, G. (2008).
Visualizing data using t-SNE.
\emph{Journal of Machine Learning Research}, \emph{9}(2579-2605).

Venna, J., Peltonen, J., Nybo, K., Aidos, H., & Kaski, S. (2010).
Information retrieval perspective to nonlinear dimensionality reduction for
data visualization.
\emph{Journal of Machine Learning Research}, \emph{11}, 451-490.

Yang, Z., King, I., Xu, Z., & Oja, E. (2009).
Heavy-tailed symmetric stochastic neighbor embedding.
In \emph{Advances in neural information processing systems} (pp. 2169-2177).

Yang, Z., Peltonen, J., & Kaski, S. (2014).
Optimization equivalence of divergences improves neighbor embedding.
In \emph{Proceedings of the 31st International Conference on Machine Learning (ICML-14)}
(pp. 460-468).
}

